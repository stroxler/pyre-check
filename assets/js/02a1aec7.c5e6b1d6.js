"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[714],{3905:(e,n,a)=>{a.r(n),a.d(n,{MDXContext:()=>s,MDXProvider:()=>u,mdx:()=>x,useMDXComponents:()=>p,withMDXComponents:()=>m});var t=a(67294);function o(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function l(){return(l=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e}).apply(this,arguments)}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function r(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach((function(n){o(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function d(e,n){if(null==e)return{};var a,t,o=function(e,n){if(null==e)return{};var a,t,o={},l=Object.keys(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||(o[a]=e[a]);return o}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=t.createContext({}),m=function(e){return function(n){var a=p(n.components);return t.createElement(e,l({},n,{components:a}))}},p=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):r(r({},n),e)),a},u=function(e){var n=p(e.components);return t.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},h=t.forwardRef((function(e,n){var a=e.components,o=e.mdxType,l=e.originalType,i=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),m=p(a),u=o,h=m["".concat(i,".").concat(u)]||m[u]||c[u]||l;return a?t.createElement(h,r(r({ref:n},s),{},{components:a})):t.createElement(h,r({ref:n},s))}));function x(e,n){var a=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var l=a.length,i=new Array(l);i[0]=h;var r={};for(var d in n)hasOwnProperty.call(n,d)&&(r[d]=n[d]);r.originalType=e,r.mdxType="string"==typeof e?e:o,i[1]=r;for(var s=2;s<l;s++)i[s]=a[s];return t.createElement.apply(null,i)}return t.createElement.apply(null,a)}h.displayName="MDXCreateElement"},21809:(e,n,a)=>{a.r(n),a.d(n,{frontMatter:()=>r,contentTitle:()=>d,metadata:()=>s,toc:()=>m,default:()=>u});var t=a(87462),o=a(63366),l=(a(67294),a(3905)),i=["components"],r={id:"pysa-model-dsl",title:"Model Domain Specific Language (DSL)",sidebar_label:"Model DSL"},d=void 0,s={unversionedId:"pysa-model-dsl",id:"pysa-model-dsl",isDocsHomePage:!1,title:"Model Domain Specific Language (DSL)",description:"We have started developing a model Domain Specific Language (DSL) that can be",source:"@site/docs/pysa_model_dsl.md",sourceDirName:".",slug:"/pysa-model-dsl",permalink:"/docs/pysa-model-dsl",editUrl:"https://github.com/facebook/pyre-check/tree/main/documentation/website/docs/pysa_model_dsl.md",tags:[],version:"current",frontMatter:{id:"pysa-model-dsl",title:"Model Domain Specific Language (DSL)",sidebar_label:"Model DSL"},sidebar:"pysa",previous:{title:"Dynamically Generating Models",permalink:"/docs/pysa-model-generators"},next:{title:"Debugging False Negatives",permalink:"/docs/pysa-false-negatives"}},m=[{value:"Basics",id:"basics",children:[]},{value:"Find clauses",id:"find-clauses",children:[]},{value:"Where clauses",id:"where-clauses",children:[{value:"<code>name.matches</code>",id:"namematches",children:[]},{value:"<code>name.equals</code>",id:"nameequals",children:[]},{value:"<code>return_annotation</code> clauses",id:"return_annotation-clauses",children:[]},{value:"<code>any_parameter</code> clauses",id:"any_parameter-clauses",children:[]},{value:"<code>AnyOf</code> clauses",id:"anyof-clauses",children:[]},{value:"<code>AllOf</code> clauses",id:"allof-clauses",children:[]},{value:"<code>Decorator</code> clauses",id:"decorator-clauses",children:[]},{value:"<code>parent.equals</code> clause",id:"parentequals-clause",children:[]},{value:"<code>parent.matches</code> clause",id:"parentmatches-clause",children:[]},{value:"<code>parent.extends</code> clause",id:"parentextends-clause",children:[]},{value:"<code>Not</code> clauses",id:"not-clauses",children:[]}]},{value:"Generated models (Model clauses)",id:"generated-models-model-clauses",children:[{value:"Returned taint",id:"returned-taint",children:[]},{value:"Parameter taint",id:"parameter-taint",children:[]},{value:"Models for attributes",id:"models-for-attributes",children:[]}]}],p={toc:m};function u(e){var n=e.components,a=(0,o.Z)(e,i);return(0,l.mdx)("wrapper",(0,t.Z)({},p,a,{components:n,mdxType:"MDXLayout"}),(0,l.mdx)("p",null,"We have started developing a model Domain Specific Language (DSL) that can be\nused to solve many of the same problems as ",(0,l.mdx)("a",{parentName:"p",href:"/docs/pysa-model-generators"},"model\ngenerators"),", while still keeping model information in\n",(0,l.mdx)("inlineCode",{parentName:"p"},".pysa")," files. The DSL aims to provide a compact way to generate models for all\ncode that matches a given query. This allows users to avoid writing hundereds or\nthousand of models."),(0,l.mdx)("h2",{id:"basics"},"Basics"),(0,l.mdx)("p",null,"The most basic form of querying Pysa's DSL is by generating models based on function names. To\ndo so, add a ",(0,l.mdx)("inlineCode",{parentName:"p"},"ModelQuery")," to your ",(0,l.mdx)("inlineCode",{parentName:"p"},".pysa")," file:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"ModelQuery(\n  # Indicates that this query is looking for functions\n  find = \"functions\",\n  # Indicates those functions should be called 'foo'\n  where = [name.matches(\"foo\")],\n  # Indicates that matched function should be modeled as returning 'Test' taint\n  model = [\n    Returns(TaintSource[Test]),\n  ]\n)\n")),(0,l.mdx)("p",null,"Things to note in this example:"),(0,l.mdx)("ol",null,(0,l.mdx)("li",{parentName:"ol"},"The ",(0,l.mdx)("inlineCode",{parentName:"li"},"find")," clause lets you pick whether you want to model functions, methods or attributes."),(0,l.mdx)("li",{parentName:"ol"},"The ",(0,l.mdx)("inlineCode",{parentName:"li"},"where")," clause is how you refine your criteria for when a model should be generated - in this example, we're filtering for functions where the name matches ",(0,l.mdx)("inlineCode",{parentName:"li"},'"foo"'),"."),(0,l.mdx)("li",{parentName:"ol"},"The ",(0,l.mdx)("inlineCode",{parentName:"li"},"model")," clause is a list of models to generate. Here, the syntax means that the functions matching the where clause should be modelled as returning ",(0,l.mdx)("inlineCode",{parentName:"li"},"TaintSource[Test]"),".")),(0,l.mdx)("p",null,"When invoking Pysa, if you add the ",(0,l.mdx)("inlineCode",{parentName:"p"},"--dump-model-query-results /path/to/output/file")," flag to your invocation, the generated models will be written to a file in JSON format."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},"$ pyre analyze --dump-model-query-results /path/to/output/file.txt\n...\n> Emitting the model query results to `/my/home/dir/.pyre/model_query_results.pysa`\n")),(0,l.mdx)("p",null,"You can then view this file to see the generated models."),(0,l.mdx)("h2",{id:"find-clauses"},"Find clauses"),(0,l.mdx)("p",null,"The ",(0,l.mdx)("inlineCode",{parentName:"p"},"find")," clause specifies what entities to model, and currently supports ",(0,l.mdx)("inlineCode",{parentName:"p"},'"functions"'),", ",(0,l.mdx)("inlineCode",{parentName:"p"},'"methods"')," and ",(0,l.mdx)("inlineCode",{parentName:"p"},'"attributes"'),". ",(0,l.mdx)("inlineCode",{parentName:"p"},'"functions"')," indicates that you're querying for free functions, ",(0,l.mdx)("inlineCode",{parentName:"p"},'"methods"')," indicates that you're only querying class methods, and ",(0,l.mdx)("inlineCode",{parentName:"p"},'"attributes"')," indicates that you're querying for attributes on classes."),(0,l.mdx)("p",null,"Note that ",(0,l.mdx)("inlineCode",{parentName:"p"},'"attributes"')," also includes constructor-initialized attributes, such as ",(0,l.mdx)("inlineCode",{parentName:"p"},"C.y")," in the following case:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"class C:\n  x = ...\n\n  def __init__(self):\n    self.y = ...\n")),(0,l.mdx)("h2",{id:"where-clauses"},"Where clauses"),(0,l.mdx)("p",null,"Where clauses are a list of predicates, all of which must match for an entity to be modelled. Note that certain predicates are only compatible with specific find clause kinds."),(0,l.mdx)("h3",{id:"namematches"},(0,l.mdx)("inlineCode",{parentName:"h3"},"name.matches")),(0,l.mdx)("p",null,"The most basic query predicate is a name match - the name you're searching for is compiled as a regex, and the entity's fully qualified name is compared against it. A fully qualified name includes the module and class - for example, for a method ",(0,l.mdx)("inlineCode",{parentName:"p"},"foo")," in class ",(0,l.mdx)("inlineCode",{parentName:"p"},"C")," which is part of module ",(0,l.mdx)("inlineCode",{parentName:"p"},"bar"),", the fully qualified name is ",(0,l.mdx)("inlineCode",{parentName:"p"},"bar.C.foo"),"."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = ...,\n  where = [\n    name.matches("foo.*")\n  ],\n  model = ...\n)\n')),(0,l.mdx)("h3",{id:"nameequals"},(0,l.mdx)("inlineCode",{parentName:"h3"},"name.equals")),(0,l.mdx)("p",null,"This clause will match when the entity's fully qualified name is exactly the same as the specified string."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = ...,\n  where = [\n    name.equals("bar.C.foo")\n  ],\n  model = ...\n)\n')),(0,l.mdx)("h3",{id:"return_annotation-clauses"},(0,l.mdx)("inlineCode",{parentName:"h3"},"return_annotation")," clauses"),(0,l.mdx)("p",null,"Model queries allow for querying based on the return annotation of a callable. Note that this ",(0,l.mdx)("inlineCode",{parentName:"p"},"where")," clause does not work when the ",(0,l.mdx)("inlineCode",{parentName:"p"},"find")," clause specifies ",(0,l.mdx)("inlineCode",{parentName:"p"},'"attributes"'),"."),(0,l.mdx)("h4",{id:"return_annotationequals"},(0,l.mdx)("inlineCode",{parentName:"h4"},"return_annotation.equals")),(0,l.mdx)("p",null,"The clause will match when the fully-qualified name of the callable's return type matches the specified value exactly."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "functions",\n  where = [\n    return_annotation.equals("django.http.HttpRequest"),\n  ],\n  model = Returns(TaintSource[UserControlled, Via[http_request]])\n)\n')),(0,l.mdx)("h4",{id:"return_annotationmatches"},(0,l.mdx)("inlineCode",{parentName:"h4"},"return_annotation.matches")),(0,l.mdx)("p",null,"This is similar to the previous clause, but will match when the fully-qualified name of the callable's return type matches the specified pattern."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "methods",\n  where = [\n    return_annotation.matches(".*Request"),\n  ],\n  model = Returns(TaintSource[UserControlled, Via[http_request]])\n)\n')),(0,l.mdx)("h4",{id:"return_annotationis_annotated_type"},(0,l.mdx)("inlineCode",{parentName:"h4"},"return_annotation.is_annotated_type")),(0,l.mdx)("p",null,"This will match when a callable's return type is annotated with ",(0,l.mdx)("a",{parentName:"p",href:"https://docs.python.org/3/library/typing.html#typing.Annotated"},(0,l.mdx)("inlineCode",{parentName:"a"},"typing.Annotated")),". This is a type used to decorate existing types with context-specific metadata, e.g."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import Annotated\n\ndef bad() -> Annotated[str, "SQL"]:\n  ...\n')),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"ModelQuery(\n  find = functions,\n  where = [\n    return_annotation.is_annotated_type(),\n  ],\n  model = Returns(TaintSource[SQL])\n)\n")),(0,l.mdx)("p",null,"This query would match on functions like the one shown above."),(0,l.mdx)("h3",{id:"any_parameter-clauses"},(0,l.mdx)("inlineCode",{parentName:"h3"},"any_parameter")," clauses"),(0,l.mdx)("p",null,"Model queries allow matching callables where any parameter matches a given clause. For now, the only clauses we support for parameters is specifying conditions on the type annotation of a callable's parameters. These can be used in conjunction with the ",(0,l.mdx)("inlineCode",{parentName:"p"},"Parameters")," model clause (see ",(0,l.mdx)("a",{parentName:"p",href:"#type_annotation-clause"},(0,l.mdx)("inlineCode",{parentName:"a"},"type_annotation")),") to taint specific parameters. Note that this ",(0,l.mdx)("inlineCode",{parentName:"p"},"where")," clause does not work when the ",(0,l.mdx)("inlineCode",{parentName:"p"},"find")," clause specifies ",(0,l.mdx)("inlineCode",{parentName:"p"},'"attributes"'),"."),(0,l.mdx)("h4",{id:"any_parameterannotationequals"},(0,l.mdx)("inlineCode",{parentName:"h4"},"any_parameter.annotation.equals")),(0,l.mdx)("p",null,"This clause will match all callables which have at least one parameter where the fully-qualified name of the parameter type matches the specified value exactly."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "functions",\n  where = [\n    any_parameter.annotation.equals("django.http.HttpRequest")\n  ],\n  model =\n    Parameters(\n      TaintSource[UserControlled],\n      where=[\n        name.equals("request"),\n        name.matches("data$")\n      ]\n    )\n)\n')),(0,l.mdx)("h4",{id:"any_parameterannotationmatches"},(0,l.mdx)("inlineCode",{parentName:"h4"},"any_parameter.annotation.matches")),(0,l.mdx)("p",null,"This clause will match all callables which have at least one parameter where the fully-qualified name of the parameter type matches the specified pattern."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "methods",\n  where = [\n    any_parameter.annotation.matches(".*Request")\n  ],\n  model =\n    Parameters(\n      TaintSource[UserControlled],\n      where=[\n        type_annotation.matches(".*Request"),\n      ]\n    )\n)\n')),(0,l.mdx)("h4",{id:"any_parameterannotationis_annotated_type"},(0,l.mdx)("inlineCode",{parentName:"h4"},"any_parameter.annotation.is_annotated_type")),(0,l.mdx)("p",null,"This clause will match all callables which have at least one parameter with type ",(0,l.mdx)("inlineCode",{parentName:"p"},"typing.Annotated"),"."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "functions",\n  where = [\n    any_parameter.annotation.is_annotated_type()\n  ],\n  model =\n    Parameters(\n      TaintSource[Test],\n      where=[\n        type_annotation.is_annotated_type(),\n      ]\n    )\n)\n')),(0,l.mdx)("h3",{id:"anyof-clauses"},(0,l.mdx)("inlineCode",{parentName:"h3"},"AnyOf")," clauses"),(0,l.mdx)("p",null,"There are cases when we want to model entities which match any of a set of clauses. The ",(0,l.mdx)("inlineCode",{parentName:"p"},"AnyOf")," clause represents exactly this case."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "methods",\n  where = [\n    AnyOf(\n      any_parameter.annotation.is_annotated_type(),\n      return_annotation.is_annotated_type(),\n    )\n  ],\n  model = ...\n)\n')),(0,l.mdx)("h3",{id:"allof-clauses"},(0,l.mdx)("inlineCode",{parentName:"h3"},"AllOf")," clauses"),(0,l.mdx)("p",null,"There are cases when we want to model entities which match all of a set of clauses. The ",(0,l.mdx)("inlineCode",{parentName:"p"},"AllOf")," clause may be used in this case."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "methods",\n  where = [\n    AnyOf(\n      AllOf(\n        parent.extends("a.b"),\n        parent.matches("Foo"),\n      ),\n      AllOf(\n        parent.extends("c.d"),\n        parent.matches("Bar")\n      )\n    )\n  ],\n  model = ...\n)\n')),(0,l.mdx)("h3",{id:"decorator-clauses"},(0,l.mdx)("inlineCode",{parentName:"h3"},"Decorator")," clauses"),(0,l.mdx)("p",null,(0,l.mdx)("inlineCode",{parentName:"p"},"Decorator")," clauses are used to find callables decorated with decorators that match a pattern. The syntax for using this clause is ",(0,l.mdx)("inlineCode",{parentName:"p"},"Decorator(<name clause>, [<arguments clause>])"),"."),(0,l.mdx)("p",null,"The first argument to ",(0,l.mdx)("inlineCode",{parentName:"p"},"Decorator")," should be a name clause, which is used to match the name of a decorator. The supported name clauses are the same as the ones discussed above for model query constraints, i.e. ",(0,l.mdx)("inlineCode",{parentName:"p"},'name.matches("pattern")'),", which will match when the decorator matches the regex pattern specified as a string, and ",(0,l.mdx)("inlineCode",{parentName:"p"},'name.equals("foo.bar.d1")')," which will match when the fully-qualified name of the decorator equals the specified string exactly."),(0,l.mdx)("p",null,"For example, if you wanted to find all functions which are decorated by ",(0,l.mdx)("inlineCode",{parentName:"p"},"@app.route()"),", a decorator imported from ",(0,l.mdx)("inlineCode",{parentName:"p"},"my_module"),", you can write:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "functions",\n  where = Decorator(name.matches("app.route")),\n  ...\n)\n')),(0,l.mdx)("p",null,"or"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "functions",\n  where = Decorator(name.equals("my_module.app.route")),\n  ...\n)\n')),(0,l.mdx)("p",null,"The second argument to ",(0,l.mdx)("inlineCode",{parentName:"p"},"Decorator")," is an optional arguments clause, which is used to match on the arguments provided to the decorator. The supported arguments clauses are ",(0,l.mdx)("inlineCode",{parentName:"p"},"arguments.contains(...)"),", which will match when the arguments specified are a subset of the decorator's arguments, and ",(0,l.mdx)("inlineCode",{parentName:"p"},"arguments.equals(...)"),", which will match when the decorator has the specified arguments exactly."),(0,l.mdx)("p",null,(0,l.mdx)("inlineCode",{parentName:"p"},"arguments.contains()")," supports both positional and keyword arguments. For positional arguments, the list of positonal arguments supplied to the ",(0,l.mdx)("inlineCode",{parentName:"p"},"arguments.contains()")," clause must be a prefix of the list of positional arguments on the actual decorator, i.e. the value of the argument at each position should be the same. For example, with the following Python code:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"@d1(a, 2)\ndef match1():\n  ...\n\n@d1(a, 2, 3, 4)\ndef match2():\n  ...\n\n@d1(2, a):\ndef nomatch():\n  ...\n")),(0,l.mdx)("p",null,"This query will match both ",(0,l.mdx)("inlineCode",{parentName:"p"},"match1()")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"match2()"),", but not ",(0,l.mdx)("inlineCode",{parentName:"p"},"nomatch()"),", since the values of the positional arguments don't match up."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "functions",\n  where = Decorator(\n    name.matches("d1"),\n    arguments.contains(a, 2)\n  ),\n  ...\n)\n')),(0,l.mdx)("p",null,"For keyword arguments in ",(0,l.mdx)("inlineCode",{parentName:"p"},"arguments.contains()"),", the specified keyword arguments must be a subset of the decorator's keyword arguments, but can be specified in any order. For example, with the following Python code:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'@d1(a, 2, foo="Bar")\ndef match1():\n  ...\n\n@d1(baz="Boo", foo="Bar")\ndef match2():\n  ...\n')),(0,l.mdx)("p",null,"This query will match both ",(0,l.mdx)("inlineCode",{parentName:"p"},"match1()")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"match2()"),":"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "functions",\n  where = Decorator(\n    name.matches("d1"),\n    arguments.contains(foo="Bar")\n  ),\n  ...\n)\n')),(0,l.mdx)("p",null,(0,l.mdx)("inlineCode",{parentName:"p"},"arguments.equals()")," operates similarly, but will only match if the specified arguments match the decorator's arguments exactly. This means that for positional arguments, all arguments in each position must match by value exactly. Keyword arguments can be specified in a different order, but the set of specified keyword arguments and the set of the decorator's actual keyword arguments must be the same. For example, with the following Python code:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'@d1(a, 2, foo="Bar", baz="Boo")\ndef match1():\n  ...\n\n@d1(a, 2, baz="Boo", foo="Bar")\ndef match2():\n  ...\n\n@d1(2, a, baz="Boo", foo="Bar")\ndef nomatch1():\n  ...\n\n@d1(a, 2, 3, baz="Boo", foo="Bar")\ndef nomatch2():\n  ...\n')),(0,l.mdx)("p",null,"This query will match both ",(0,l.mdx)("inlineCode",{parentName:"p"},"match1()")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"match2()"),", but not ",(0,l.mdx)("inlineCode",{parentName:"p"},"nomatch1()")," or ",(0,l.mdx)("inlineCode",{parentName:"p"},"nomatch2()"),":"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "functions",\n  where = Decorator(\n    name.matches("d1"),\n    arguments.equals(a, 2, foo="bar", baz="Boo")\n  ),\n  ...\n)\n')),(0,l.mdx)("h3",{id:"parentequals-clause"},(0,l.mdx)("inlineCode",{parentName:"h3"},"parent.equals")," clause"),(0,l.mdx)("p",null,"You may use the ",(0,l.mdx)("inlineCode",{parentName:"p"},"parent")," clause to specify predicates on the parent class. This predicate can only be used when the find clause specifies methods or attributes."),(0,l.mdx)("p",null,"The ",(0,l.mdx)("inlineCode",{parentName:"p"},"parent.equals")," clause is used to model entities when the parent's fully qualified name is an exact match for the specified string."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "methods",\n  where = parent.equals("foo.Bar"),\n  ...\n)\n')),(0,l.mdx)("h3",{id:"parentmatches-clause"},(0,l.mdx)("inlineCode",{parentName:"h3"},"parent.matches")," clause"),(0,l.mdx)("p",null,"The ",(0,l.mdx)("inlineCode",{parentName:"p"},"parent.matches")," clause is used to model entities when the parent's fully qualified name matches the provided regex."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "methods",\n  where = parent.matches(".*Foo.*"),\n  ...\n)\n')),(0,l.mdx)("h3",{id:"parentextends-clause"},(0,l.mdx)("inlineCode",{parentName:"h3"},"parent.extends")," clause"),(0,l.mdx)("p",null,"The ",(0,l.mdx)("inlineCode",{parentName:"p"},"parent.extends")," clause is used to model entities when the parent's class is a subclass of the provided class name."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "attributes",\n  where = parent.extends("C"),\n  ...\n)\n')),(0,l.mdx)("p",null,"The default behavior is that it will only match if the parent class is an instance of, or a direct subclass of the specified class. For example, with classes:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"class C:\n  x = ...\n\nclass D(C):\n  y = ...\n\nclass E(D):\n  z = ...\n")),(0,l.mdx)("p",null,"the above query will only model the attributes ",(0,l.mdx)("inlineCode",{parentName:"p"},"C.z")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"D.y"),", since ",(0,l.mdx)("inlineCode",{parentName:"p"},"C")," is considered to extend itself, and ",(0,l.mdx)("inlineCode",{parentName:"p"},"D")," is a direct subclass of ",(0,l.mdx)("inlineCode",{parentName:"p"},"C"),". However, it will not model ",(0,l.mdx)("inlineCode",{parentName:"p"},"E.z"),", since ",(0,l.mdx)("inlineCode",{parentName:"p"},"E")," is a sub-subclass of ",(0,l.mdx)("inlineCode",{parentName:"p"},"C"),"."),(0,l.mdx)("p",null,"If you would like to model a class and all subclasses transitively, you can use the ",(0,l.mdx)("inlineCode",{parentName:"p"},"is_transitive")," flag to get this behavior."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "attributes",\n  where = parent.extends("C", is_transitive=True),\n  ...\n)\n')),(0,l.mdx)("p",null,"This query will model ",(0,l.mdx)("inlineCode",{parentName:"p"},"C.x"),", ",(0,l.mdx)("inlineCode",{parentName:"p"},"D.y")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"E.z"),"."),(0,l.mdx)("h3",{id:"not-clauses"},(0,l.mdx)("inlineCode",{parentName:"h3"},"Not")," clauses"),(0,l.mdx)("p",null,"The ",(0,l.mdx)("inlineCode",{parentName:"p"},"Not")," clause negates any existing clause that is valid for the entity being modelled."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "methods",\n  where = [\n    Not(\n      name.matches("foo.*"),\n      parent.matches("testing.unittest.UnitTest"),\n    )\n  ],\n  model = ...\n)\n')),(0,l.mdx)("h2",{id:"generated-models-model-clauses"},"Generated models (Model clauses)"),(0,l.mdx)("p",null,"The last bit of model queries is actually generating models for all entities that match the provided where clauses. For callables, we support generating models for parameters by name or position, as well as generating models for all paramaters. Additionally, we support generating models for the return annotation."),(0,l.mdx)("h3",{id:"returned-taint"},"Returned taint"),(0,l.mdx)("p",null,"Returned taint takes the form of ",(0,l.mdx)("inlineCode",{parentName:"p"},"Returns(TaintSpecification)"),", where ",(0,l.mdx)("inlineCode",{parentName:"p"},"TaintSpecification")," is either a taint annotation or a list of taint annotations."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "methods",\n  where = ...,\n  model = [\n    Returns(TaintSource[Test, Via[foo]])\n  ]\n)\n')),(0,l.mdx)("h3",{id:"parameter-taint"},"Parameter taint"),(0,l.mdx)("p",null,"Parameters can be tainted using the ",(0,l.mdx)("inlineCode",{parentName:"p"},"Parameters()")," clause. By default, all parameters will be tained with the supplied taint specification. If you would like to only taint specific parameters matching certain conditions, an optional ",(0,l.mdx)("inlineCode",{parentName:"p"},"where")," clause can be specified to accomplish this, allowing for constraints on parameter names, the annotation type of the parameter, or parameter position. For example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "methods",\n  where = ...,\n  model = [\n    Parameters(TaintSource[A]), # will taint all parameters by default\n    Parameters(\n      TaintSource[B],\n      where=[\n        Not(index.equals(0))   # will only taint parameters that are not the first parameter\n      ]\n    ),\n  ]\n)\n')),(0,l.mdx)("h4",{id:"name-clauses"},(0,l.mdx)("inlineCode",{parentName:"h4"},"name")," clauses"),(0,l.mdx)("p",null,"To specify a constraint on parameter name, the ",(0,l.mdx)("inlineCode",{parentName:"p"},"name.equals()")," or ",(0,l.mdx)("inlineCode",{parentName:"p"},"name.matches()")," clauses can be used. As in the main ",(0,l.mdx)("inlineCode",{parentName:"p"},"where")," clause of the model query, ",(0,l.mdx)("inlineCode",{parentName:"p"},"equals()")," searches for an exact match on the specified string, while ",(0,l.mdx)("inlineCode",{parentName:"p"},"matches()")," allows a regex to be supplied as a pattern to match against."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "methods",\n  where = ...,\n  model = [\n    Parameters(\n      TaintSource[Test],\n      where=[\n        name.equals("request"),\n        name.matches("data$")\n      ]\n    )\n  ]\n)\n')),(0,l.mdx)("h4",{id:"index-clause"},(0,l.mdx)("inlineCode",{parentName:"h4"},"index")," clause"),(0,l.mdx)("p",null,"To specify a constraint on parameter position, the ",(0,l.mdx)("inlineCode",{parentName:"p"},"index.equals()")," clause can be used. It takes a single integer denoting the position of the parameter."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "methods",\n  where = ...,\n  model = [\n    Parameters(\n      TaintSource[Test],\n      where=[\n        index.equals(1)\n      ]\n    )\n  ]\n)\n')),(0,l.mdx)("h4",{id:"type_annotation-clause"},(0,l.mdx)("inlineCode",{parentName:"h4"},"type_annotation")," clause"),(0,l.mdx)("p",null,"This clause is used to specify a constraint on parameter type annotation. Currently the clauses supported are: ",(0,l.mdx)("inlineCode",{parentName:"p"},"type_annotation.equals()"),", which takes the fully-qualified name of a Python type or class and matches when there is an exact match, ",(0,l.mdx)("inlineCode",{parentName:"p"},"type_annotation.matches()"),", which takes a regex pattern to match type annotations against, and ",(0,l.mdx)("inlineCode",{parentName:"p"},"type_annotation.is_annotated_type()"),", which will match parameters of type ",(0,l.mdx)("a",{parentName:"p",href:"https://docs.python.org/3/library/typing.html#typing.Annotated"},(0,l.mdx)("inlineCode",{parentName:"a"},"typing.Annotated")),"."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "methods",\n  where = ...,\n  model = [\n    Parameters(\n      TaintSource[Test],\n      where=[\n        type_annotation.equals("foo.bar.C"),  # exact match\n        type_annotation.matches("^List\\["),   # regex match\n        type_annotation.is_annotated_type(),  # matches Annotated[T, x]\n      ]\n    )\n  ]\n)\n')),(0,l.mdx)("p",null,"To match on the annotation portion of ",(0,l.mdx)("inlineCode",{parentName:"p"},"Annotated")," types, consider the following example. Suppose this code was in ",(0,l.mdx)("inlineCode",{parentName:"p"},"test.py"),":"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'from enum import Enum\nfrom typing import Annotated, Option\n\nclass Color(Enum):\n    RED = 1\n    GREEN = 2\n    BLUE = 3\n\nclass Foo:\n  x: Annotated[Optional[int], Color.RED]\n  y: Annotated[Optional[int], Color.BLUE]\n  z: Annotated[int, "z"]\n')),(0,l.mdx)("p",null,"Note that the type name that should be matched against is its fully qualified name, which also includes the fully qualified name of any other types referenced (for example, ",(0,l.mdx)("inlineCode",{parentName:"p"},"typing.Optional")," rather than just ",(0,l.mdx)("inlineCode",{parentName:"p"},"Optional"),"). When multiple arguments are provided to the type they are implicitly treated as being in a tuple."),(0,l.mdx)("p",null,"Here are some examples of ",(0,l.mdx)("inlineCode",{parentName:"p"},"where")," clauses that can be used to specify models for the annotated attributes in this case:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "attributes",\n  where = [\n    AnyOf(\n      type_annotation.equals("typing.Annotated[(typing.Optional[int], test.Color.RED)]"),\n      type_annotation.equals("typing.Annotated[(int, z)]"),\n      type_annotation.matches(".*Annotated\\[.*Optional[int].*Color\\..*\\]")\n      type_annotation.is_annotated_type()\n    )\n  ],\n  model = [\n    AttributeModel(TaintSource[Test]),\n  ]\n)\n')),(0,l.mdx)("p",null,"This query should generate the following models:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},"test.Foo.x: TaintSource[Test]\ntest.Foo.y: TaintSource[Test]\ntest.Foo.z: TaintSource[Test]\n")),(0,l.mdx)("h4",{id:"not-and-anyof-clauses"},(0,l.mdx)("inlineCode",{parentName:"h4"},"Not")," and ",(0,l.mdx)("inlineCode",{parentName:"h4"},"AnyOf")," clauses"),(0,l.mdx)("p",null,"The ",(0,l.mdx)("inlineCode",{parentName:"p"},"Not"),", ",(0,l.mdx)("inlineCode",{parentName:"p"},"AllOf")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"AnyOf")," clauses can be used in the same way as they are in the main ",(0,l.mdx)("inlineCode",{parentName:"p"},"where")," clause of the model query. ",(0,l.mdx)("inlineCode",{parentName:"p"},"Not")," can be used to negate any existing clause, ",(0,l.mdx)("inlineCode",{parentName:"p"},"AllOf")," to match when all of several supplied clauses match, and ",(0,l.mdx)("inlineCode",{parentName:"p"},"AnyOf")," can be used to match when any one of several supplied clauses match."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "methods",\n  where = ...,\n  model = [\n    Parameters(\n      TaintSource[Test],\n      where=[\n        Not(\n          AnyOf(\n            AllOf(\n              parent.extends("a.b"),\n              parent.matches("Foo"),\n            ),\n            AllOf(\n              parent.extends("c.d"),\n              parent.matches("Bar")\n            )\n          )\n        )\n      ]\n    )\n  ]\n)\n')),(0,l.mdx)("h4",{id:"using-viatypeof-with-the-parameters-clause"},"Using ",(0,l.mdx)("inlineCode",{parentName:"h4"},"ViaTypeOf")," with the ",(0,l.mdx)("inlineCode",{parentName:"h4"},"Parameters")," clause"),(0,l.mdx)("p",null,"Usually when specifying a ",(0,l.mdx)("inlineCode",{parentName:"p"},"ViaTypeOf")," the argument that you want to capture the value or type of should be specified. However, when writing model queries and trying to find all parameters that match certain conditions, we may not know the exact name of the parameters that will be modelled. For example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def f1(bad_1, good_1, good_2):\n  pass\n\ndef f2(good_3, bad_2, good_4):\n  pass\n")),(0,l.mdx)("p",null,"Suppose we wanted to model all parameters with the prefix ",(0,l.mdx)("inlineCode",{parentName:"p"},"bad_")," here and attach a ",(0,l.mdx)("inlineCode",{parentName:"p"},"ViaTypeOf")," to them. In this case it is still possible to attach these features to the parameter model, by using a standalone ",(0,l.mdx)("inlineCode",{parentName:"p"},"ViaTypeOf")," as follows:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "functions",\n  where = name.matches("f"),\n  model = [\n    Parameters(\n      TaintSink[Test, ViaTypeOf],\n      where=[\n        name.matches("bad_")\n      ]\n    )\n  ]\n)\n')),(0,l.mdx)("p",null,"This would produce models equivalent to the following:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def f1(bad_1: TaintSink[Test, ViaTypeOf[bad_1]]): ...\ndef f2(bad_2: TaintSink[Test, ViaTypeOf[bad_2]]): ...\n")),(0,l.mdx)("h3",{id:"models-for-attributes"},"Models for attributes"),(0,l.mdx)("p",null,"Taint for attribute models requires a ",(0,l.mdx)("inlineCode",{parentName:"p"},"AttributeModel")," model clause, which can only be used when the find clause specifies attributes."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "attributes",\n  where = ...,\n  model = [\n    AttributeModel(TaintSource[Test], TaintSink[Test])\n  ]\n)\n')))}u.isMDXComponent=!0}}]);