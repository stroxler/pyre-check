"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4709],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>p,MDXProvider:()=>u,mdx:()=>h,useMDXComponents:()=>c,withMDXComponents:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(){return o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},o.apply(this,arguments)}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),d=function(e){return function(t){var n=c(t.components);return a.createElement(e,o({},t,{components:n}))}},c=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},y=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),u=r,y=d["".concat(i,".").concat(u)]||d[u]||m[u]||o;return n?a.createElement(y,s(s({ref:t},p),{},{components:n})):a.createElement(y,s({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=y;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}y.displayName="MDXCreateElement"},17715:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>p,toc:()=>c});var a=n(83117),r=n(80102),o=(n(67294),n(3905)),i=["components"],s={id:"types-in-python",title:"Types in Python",sidebar_label:"Introduction"},l=void 0,p={unversionedId:"types-in-python",id:"types-in-python",title:"Types in Python",description:"Python's type system was specified in PEP 484. If you are new to Python's type system and want to learn the basics, we highly recommend you take a look at mypy's cheatsheet as well as their type system reference. The following discussion focuses on Pyre's approach to \"gradual typing\" and how you can get from an untyped codebase to a fully typed codebase.",source:"@site/docs/gradual_typing.md",sourceDirName:".",slug:"/types-in-python",permalink:"/docs/types-in-python",draft:!1,editUrl:"https://github.com/facebook/pyre-check/tree/main/documentation/website/docs/gradual_typing.md",tags:[],version:"current",frontMatter:{id:"types-in-python",title:"Types in Python",sidebar_label:"Introduction"},sidebar:"pyre",previous:{title:"Types in Python",permalink:"/docs/category/types-in-python"},next:{title:"Type Errors",permalink:"/docs/errors"}},d={},c=[{value:"Why Types?",id:"why-types",level:2},{value:"Gradual Typing",id:"gradual-typing",level:2},{value:"Strict Mode",id:"strict-mode",level:2},{value:"Strict-By-Default",id:"strict-by-default",level:3},{value:"When Source Code is not Available",id:"when-source-code-is-not-available",level:2},{value:"Typeshed",id:"typeshed",level:3},{value:"Strategies for Increasing Coverage",id:"strategies-for-increasing-coverage",level:2},{value:"Upgrade",id:"upgrade",level:3},{value:"Automatic Type Inference",id:"automatic-type-inference",level:3}],u={toc:c};function m(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.mdx)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"Python's type system was specified in ",(0,o.mdx)("a",{parentName:"p",href:"https://www.python.org/dev/peps/pep-0484/"},"PEP 484"),". If you are new to Python's type system and want to learn the basics, we highly recommend you take a look at ",(0,o.mdx)("a",{parentName:"p",href:"https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html"},"mypy's cheatsheet")," as well as their ",(0,o.mdx)("a",{parentName:"p",href:"https://mypy.readthedocs.io/en/stable/builtin_types.html"},"type system reference"),'. The following discussion focuses on Pyre\'s approach to "gradual typing" and how you can get from an untyped codebase to a fully typed codebase.'),(0,o.mdx)("h2",{id:"why-types"},"Why Types?"),(0,o.mdx)("h2",{id:"gradual-typing"},"Gradual Typing"),(0,o.mdx)("p",null,"Most Python code does not (yet) start out typed. PEP 484 specifies a ",(0,o.mdx)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Gradual_typing"},"gradual type system"),", which is built to allow you to ",(0,o.mdx)("em",{parentName:"p"},"gradually")," add annotations over time. It does so by"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"only reporting errors on functions that have an explicit return or parameter type annotation,"),(0,o.mdx)("li",{parentName:"ul"},"introducing an escape hatch: a special type ",(0,o.mdx)("inlineCode",{parentName:"li"},"Any")," that has all possible attributes and is both sub- and super-type of any other type,"),(0,o.mdx)("li",{parentName:"ul"},"and assuming that all untyped fuctions implicitly return ",(0,o.mdx)("inlineCode",{parentName:"li"},"Any"),".")),(0,o.mdx)("p",null,"For example,"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import List\n\ndef unannotated():        # implictly returns `Any`\n    return b"" + ""       # function body is not checked\n\ndef annotated() -> List:  # explicit return annotation means we type check `annotated`\n    any = unannotated()\n    any.attribute         # `Any` has all possible attributes\n    return 1              # Error: returning `int` but expecting `List`\n')),(0,o.mdx)("p",null,"In combination, these rules allow you to slowly annotate code without getting overwhelmed by type errors in one sitting. Incrementally adding more annotations will give you stronger safety and consistency guarantees in your codebase."),(0,o.mdx)("p",null,"In the example above, if you changed ",(0,o.mdx)("inlineCode",{parentName:"p"},"unannotated")," to return ",(0,o.mdx)("inlineCode",{parentName:"p"},"str"),", you would get a type error when accessing the attribute ",(0,o.mdx)("inlineCode",{parentName:"p"},"any.attribute")," in ",(0,o.mdx)("inlineCode",{parentName:"p"},"annotated"),"."),(0,o.mdx)("h2",{id:"strict-mode"},"Strict Mode"),(0,o.mdx)("p",null,"While ",(0,o.mdx)("inlineCode",{parentName:"p"},"Any")," is a necessary escape hatch when annotating large codebases over time, it can hide legitimate type errors. We've introduced ",(0,o.mdx)("em",{parentName:"p"},"strict mode")," in Pyre to address this problem. Strict mode can be toggled at a module level by introducing a ",(0,o.mdx)("inlineCode",{parentName:"p"},"# pyre-strict")," comment to the file. In strict mode, Pyre will"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"run on all functions, whether they are annotated or not,"),(0,o.mdx)("li",{parentName:"ul"},"error on functions, globals, or attributes that are missing annotations,"),(0,o.mdx)("li",{parentName:"ul"},"and error on annotations containing ",(0,o.mdx)("inlineCode",{parentName:"li"},"Any")," (with some exceptions to accommodate for common patterns).")),(0,o.mdx)("p",null,"In our previous example,"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'# pyre-strict\nfrom typing import List\n\ndef unannotated():        # Error: missing return annotation\n    return b"" + ""       # Error: function body *is* checked\n\ndef annotated() -> List:  # Error: implicit `Any` for generic parameter to `List`\n    any = unannotated()\n    any.attribute         # Note: the type of `any` is still any.\n    return 1              # Error: returning `int` but expecting `List`\n')),(0,o.mdx)("p",null,"As you can see in the example, ",(0,o.mdx)("inlineCode",{parentName:"p"},"Any")," can still sneak into modules that are strict, but increasing strict coverage and fixing the surfaced errors will gradually eliminate them."),(0,o.mdx)("h3",{id:"strict-by-default"},"Strict-By-Default"),(0,o.mdx)("p",null,"Strict mode can also be set as the default in a ",(0,o.mdx)("a",{parentName:"p",href:"/docs/configuration"},"project configuration"),". To opt individual files out of strict mode, use ",(0,o.mdx)("inlineCode",{parentName:"p"},"# pyre-unsafe")," in place of ",(0,o.mdx)("inlineCode",{parentName:"p"},"# pyre-strict"),"."),(0,o.mdx)("h2",{id:"when-source-code-is-not-available"},"When Source Code is not Available"),(0,o.mdx)("p",null,"We do not always have access to all the source code that contributes type information to our project: e.g. ",(0,o.mdx)("inlineCode",{parentName:"p"},"builtins")," is compiled native code, and other libraries may be using ",(0,o.mdx)("em",{parentName:"p"},"Cython"),". Other times, we may be working with Python code that is just too dynamic to be reasonably typed."),(0,o.mdx)("p",null,"To address these cases, Pyre will give precedence to type ",(0,o.mdx)("em",{parentName:"p"},"stub files")," with a ",(0,o.mdx)("inlineCode",{parentName:"p"},"*.pyi")," extension over source files when these are specified in the search path in the ",(0,o.mdx)("a",{parentName:"p",href:"/docs/configuration"},"project configuration")," or if they are located next to the implementation file.\nStub files have the same structure as implementation files but only contain class and function signatures:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# my_dynamic_module.pyi\ndef dynamic_function() -> int: ...   # Function body is omitted\n")),(0,o.mdx)("p",null,"If a ",(0,o.mdx)("inlineCode",{parentName:"p"},"__getattr__")," function is defined in the stub file as follows, Pyre will take it as a signal that the stub file is partially complete: accessing attributes whose name is not defined in the stub file will result in ",(0,o.mdx)("inlineCode",{parentName:"p"},"Any")," instead of a type error."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# my_stub.pyi\nfrom typing import Any\nfoo: int = 42\n# Parameter needs to be typed as `str` and return type needs to be `Any`\ndef __getattr__(name: str) -> Any: ...\n\n# my_source.py\nimport my_stub\nreveal_type(my_stub.foo)        # Reveals `int`\nreveal_type(my_stub.undefined)  # Reveals `Any`\n")),(0,o.mdx)("h3",{id:"typeshed"},"Typeshed"),(0,o.mdx)("h2",{id:"strategies-for-increasing-coverage"},"Strategies for Increasing Coverage"),(0,o.mdx)("p",null,"Pyre comes with tooling to make it easy to increase type coverage in your project."),(0,o.mdx)("h3",{id:"upgrade"},"Upgrade"),(0,o.mdx)("p",null,"When upgrading the type checker, new errors inevitably get surfaced. In order to keep a codebase clean through upgrades we've built ",(0,o.mdx)("inlineCode",{parentName:"p"},"pyre-upgrade"),", which automatically ",(0,o.mdx)("a",{parentName:"p",href:"/docs/errors#suppression"},"suppresses")," newly surfaced type errors. It takes Pyre's output and adds supression comments to the code explaining what's wrong so that developers can easily address the issues individually."),(0,o.mdx)("p",null,"You can run ",(0,o.mdx)("inlineCode",{parentName:"p"},"pyre-upgrade")," with"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-bash"},"(venv) $ pyre --output=json | pyre-upgrade fixme\n")),(0,o.mdx)("p",null,"or if you are using a local configuration"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-bash"},"(venv) $ pyre --output=json -l <project> | pyre-upgrade fixme\n")),(0,o.mdx)("h3",{id:"automatic-type-inference"},"Automatic Type Inference"),(0,o.mdx)("p",null,"We have found tools that automatically add type annotations to code useful to get started with a project. There are two general approaches to automatic type inference: static inference and dynamic inference from runtime information. Both approaches come with their own trade-offs and we have found a combination of the two to be useful."),(0,o.mdx)("p",null,"Pyre can do static type inference. You can run"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-bash"},"(venv) $ cd <path to project>; pyre infer -i\n")),(0,o.mdx)("p",null,"to automatically apply annotations."),(0,o.mdx)("p",null,"For dynamic inference we recommend you give ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/Instagram/MonkeyType"},"MonkeyType")," a try."))}m.isMDXComponent=!0}}]);