"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[108],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>d,MDXProvider:()=>u,mdx:()=>f,useMDXComponents:()=>p,withMDXComponents:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},r.apply(this,arguments)}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var d=a.createContext({}),m=function(e){return function(t){var n=p(t.components);return a.createElement(e,r({},t,{components:n}))}},p=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(d.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=p(n),u=o,h=m["".concat(i,".").concat(u)]||m[u]||c[u]||r;return n?a.createElement(h,l(l({ref:t},d),{},{components:n})):a.createElement(h,l({ref:t},d))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var d=2;d<r;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},35619:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>s,default:()=>c,frontMatter:()=>l,metadata:()=>d,toc:()=>p});var a=n(83117),o=n(80102),r=(n(67294),n(3905)),i=["components"],l={id:"pysa-false-positives-negatives",title:"Debugging False Positives and False Negatives",sidebar_label:"Debugging False Positives and False Negatives"},s=void 0,d={unversionedId:"pysa-false-positives-negatives",id:"pysa-false-positives-negatives",title:"Debugging False Positives and False Negatives",description:"False Positives occur when Pysa finds an issue that is not valid, either because",source:"@site/docs/pysa_false_positives_negatives.md",sourceDirName:".",slug:"/pysa-false-positives-negatives",permalink:"/docs/pysa-false-positives-negatives",draft:!1,editUrl:"https://github.com/facebook/pyre-check/tree/main/documentation/website/docs/pysa_false_positives_negatives.md",tags:[],version:"current",frontMatter:{id:"pysa-false-positives-negatives",title:"Debugging False Positives and False Negatives",sidebar_label:"Debugging False Positives and False Negatives"},sidebar:"pysa",previous:{title:"Model DSL",permalink:"/docs/pysa-model-dsl"},next:{title:"Exploring Taint Models Interactively",permalink:"/docs/pysa-explore"}},m={},p=[{value:"Common Causes of False Positives",id:"common-causes-of-false-positives",level:2},{value:"Taint collapsing",id:"taint-collapsing",level:3},{value:"Common Causes of False Negatives",id:"common-causes-of-false-negatives",level:2},{value:"Missing Type Information",id:"missing-type-information",level:3},{value:"Missing Sources/Sinks",id:"missing-sourcessinks",level:4},{value:"Incomplete Call Graph",id:"incomplete-call-graph",level:4},{value:"Globals",id:"globals",level:3},{value:"Methodology for Debugging False Positives and False Negatives",id:"methodology-for-debugging-false-positives-and-false-negatives",level:2},{value:"Reveal taint approach",id:"reveal-taint-approach",level:3},{value:"Model explorer approach",id:"model-explorer-approach",level:3},{value:"Example using <code>reveal_taint</code>",id:"example-using-reveal_taint",level:3},{value:"Appendix",id:"appendix",level:2}],u={toc:p};function c(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.mdx)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"False Positives")," occur when Pysa finds an issue that is not valid, either because\nthe flow cannot actually happen or because it is not a security risk."),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"False Negatives")," occur when there is a legitimate flow of tainted data from a\nsource to a sink, but Pysa fails to catch it."),(0,r.mdx)("h2",{id:"common-causes-of-false-positives"},"Common Causes of False Positives"),(0,r.mdx)("h3",{id:"taint-collapsing"},"Taint collapsing"),(0,r.mdx)("p",null,"Pysa uses a set of heuristics in order to make the analysis scale to millions\nof lines of code. The main heuristic is called taint collapsing, which happens\nwhen Pysa is tracking too many attributes of an object or keys of a dictionary.\nTo avoid blowing up, Pysa will collapse taint, and assume the whole object is\ntainted. Pysa will use sane defaults, but heuristics can be ",(0,r.mdx)("a",{parentName:"p",href:"/docs/pysa-advanced##tune-the-taint-tree-width-and-depth"},"tuned using\ncommand line options or a taint configuration\nfile"),"."),(0,r.mdx)("p",null,"Taint collapsing also happens when taint flows through a function that Pysa does\nnot have the code for. To be sound, it assumes functions without code\nautomatically propagate taint on arguments to their return value. This can be\navoided by providing a model for these functions using\n",(0,r.mdx)("a",{parentName:"p",href:"/docs/pysa-advanced##obscure-models"},(0,r.mdx)("inlineCode",{parentName:"a"},"@SkipObscure")),"."),(0,r.mdx)("h2",{id:"common-causes-of-false-negatives"},"Common Causes of False Negatives"),(0,r.mdx)("h3",{id:"missing-type-information"},"Missing Type Information"),(0,r.mdx)("p",null,"Pysa relies on type information from Pyre to identify sources and sinks, and to\nbuild the call graph needed to follow the propagation of taint between the two.\nJust because type information is available ",(0,r.mdx)("em",{parentName:"p"},"somewhere")," in the code, does not\nmean Pyre will know the type of an object in the exact place where Pysa needs\nit. See the documentation on ",(0,r.mdx)("a",{parentName:"p",href:"/docs/pysa-coverage"},"Coverage Increasing\nStrategies")," for tips on how to increase type\ncoverage. The following examples demonstrate how lost type information leads to\nlost flows."),(0,r.mdx)("h4",{id:"missing-sourcessinks"},"Missing Sources/Sinks"),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"HttpRequest.GET")," is a common source of ",(0,r.mdx)("inlineCode",{parentName:"p"},"UserControlled")," data in Django. If the\n",(0,r.mdx)("inlineCode",{parentName:"p"},"request")," objects are not explicitly typed as ",(0,r.mdx)("inlineCode",{parentName:"p"},"HttpRequest"),", however, Pysa will\nfail to detect obvious issues:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"from django.http import HttpRequest\n\ndef this_is_missed(request):\n    # This flow WILL NOT be found, because Pysa does not know the type of\n    # 'request' at this point and thus does not know 'request.GET' is a source\n    # (even though the type is known in 'run')\n    eval(request.GET[\"command\"])\n\ndef this_is_caught(request: HttpRequest):\n    # This flow WILL be found.\n    eval(request.GET[\"command\"])\n\ndef run(request: HttpRequest):\n    this_is_missed(request)\n    this_is_caught(request)\n")),(0,r.mdx)("h4",{id:"incomplete-call-graph"},"Incomplete Call Graph"),(0,r.mdx)("p",null,"Pysa relies on type information in order to build a call graph that accurately\ntracks a method call of ",(0,r.mdx)("inlineCode",{parentName:"p"},"foo.bar(x)")," to the ",(0,r.mdx)("inlineCode",{parentName:"p"},"def bar(self, x)")," implementation.\nWithout type information on ",(0,r.mdx)("inlineCode",{parentName:"p"},"bar"),", Pysa will be unable to figure out how to\ndispatch the call and the flow will be lost:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"from django.http import HttpRequest\n\nclass Runner:\n    def run(self, command: str) -> None:\n        eval(command)\n\ndef this_is_missed(request: HttpRequest, runner):\n    # This flow WILL NOT be found, because Pysa does not know the type of\n    # 'runner', and thus does not know where the 'run' call dispatches to\n    runner.run(request.GET[\"command\"])\n\ndef this_is_caught(request: HttpRequest, runner: Runner):\n    # This flow WILL be found.\n    runner.run(request.GET[\"command\"])\n")),(0,r.mdx)("h3",{id:"globals"},"Globals"),(0,r.mdx)("p",null,"To allow for parallel processing, Pysa is limited in it's ability to track taint\nflows through global variables. For example, Pysa will not detect an issue in\nthe following code:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'user_controlled_data = ""\n\ndef load_data(request: HttpRequest) -> None:\n    user_controlled_data = request.GET["data"]\n\ndef run_command(request: HttpRequest) -> None:\n    load_data(request)\n    eval(user_controlled_data)\n')),(0,r.mdx)("p",null,"The best workaround is to avoid using globals in your code. If a refactor isn't\npossible, but you do know what globals should be considered tainted, you can\nexplicitly declare the global tainted in your ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," files."),(0,r.mdx)("h2",{id:"methodology-for-debugging-false-positives-and-false-negatives"},"Methodology for Debugging False Positives and False Negatives"),(0,r.mdx)("p",null,"There are two recommended ways to debug false positives and false negatives."),(0,r.mdx)("p",null,"If the analysis is reasonably fast on your code, or that you are able to\nreproduce the false positive or false negative on a smaller code, you can use\nthe ",(0,r.mdx)("a",{parentName:"p",href:"#reveal-taint-approach"},"reveal_taint")," approach."),(0,r.mdx)("p",null,"If, instead, the analysis is slow on your code (say, more than 5 minutes) and\nthat you are unable to reproduce on a small example, you can use the ",(0,r.mdx)("a",{parentName:"p",href:"#model-explorer-approach"},"model\nexplorer")," approach."),(0,r.mdx)("p",null,"In all cases, you should first:"),(0,r.mdx)("ol",null,(0,r.mdx)("li",{parentName:"ol"},"Identify the flow you expect to see (or not see):",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Source"),(0,r.mdx)("li",{parentName:"ul"},"Sink"),(0,r.mdx)("li",{parentName:"ul"},"Every function call/return that propagates the tainted data from the source\nto the sink"),(0,r.mdx)("li",{parentName:"ul"},"Every variable that the tainted data passes through, within the identified\nfunctions. This usually includes the parameter which initially received\nthe taint, and then 0 or more local variables that hold the tainted data\nas it is transformed in some way.")))),(0,r.mdx)("h3",{id:"reveal-taint-approach"},"Reveal taint approach"),(0,r.mdx)("p",null,"This approach is based on the magic functions\n",(0,r.mdx)("a",{parentName:"p",href:"/docs/pysa-tips#reveal_taintyour_variable"},(0,r.mdx)("inlineCode",{parentName:"a"},"reveal_taint"))," and\n",(0,r.mdx)("a",{parentName:"p",href:"/docs/pysa-tips#reveal_typeyour_variable"},(0,r.mdx)("inlineCode",{parentName:"a"},"reveal_type")),"."),(0,r.mdx)("ol",{start:2},(0,r.mdx)("li",{parentName:"ol"},"Add a ",(0,r.mdx)("inlineCode",{parentName:"li"},"reveal_taint")," and ",(0,r.mdx)("inlineCode",{parentName:"li"},"reveal_type")," statement to each of the variables\nthat must be tainted (or not), as identified in step 1."),(0,r.mdx)("li",{parentName:"ol"},"Start following the flow from source to sink in your code, and find the\ncorresponding output for each ",(0,r.mdx)("inlineCode",{parentName:"li"},"reveal_taint")," statement.",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Note that each time Pysa analyzes a function (could be many times), it will\ndump the latest taint information, so ",(0,r.mdx)("strong",{parentName:"li"},"the last instance of ",(0,r.mdx)("inlineCode",{parentName:"strong"},"reveal_taint"),"\noutput for a given line will be the most accurate and is the one you should\nlook at.")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"reveal_taint")," output exposes some of the ",(0,r.mdx)("a",{parentName:"li",href:"/docs/pysa-implementation-details"},"implementation\ndetails")," of Pysa, by giving you ",(0,r.mdx)("inlineCode",{parentName:"li"},"Revealed\nforward taint")," and ",(0,r.mdx)("inlineCode",{parentName:"li"},"Revealed backward taint")," messages. Without going into\nthose details, you should expect to see ",(0,r.mdx)("em",{parentName:"li"},"either")," the source name (eg.\n",(0,r.mdx)("inlineCode",{parentName:"li"},"UserControlled"),") you care about appearing in the ",(0,r.mdx)("inlineCode",{parentName:"li"},"Revealed forward taint"),"\noutput, or the sink name (eg. ",(0,r.mdx)("inlineCode",{parentName:"li"},"RemoteCodeExecution"),") you care about in the\n",(0,r.mdx)("inlineCode",{parentName:"li"},"Revealed backward taint")," output."),(0,r.mdx)("li",{parentName:"ul"},"For each ",(0,r.mdx)("inlineCode",{parentName:"li"},"reveal_taint"),", following the flow of tainted data from source to\nsink, locate the output in the logs that reveals the taint (eg.\n",(0,r.mdx)("inlineCode",{parentName:"li"},"integration_test.reveal_taint:20:4-20:16: Revealed forward taint for\n ``command``:"),")."),(0,r.mdx)("li",{parentName:"ul"},"If you see your source or sink name in the output, then go back to 1) and\ncarry on with the next ",(0,r.mdx)("inlineCode",{parentName:"li"},"reveal_taint")," statement. If you ",(0,r.mdx)("em",{parentName:"li"},"do not")," see the\nsource or sink name, then that means the cause of the false negative is\nlikely between your previous ",(0,r.mdx)("inlineCode",{parentName:"li"},"reveal_taint"),' and the one you\'re currently\nlooking at. Refer to the "Commom Causes of False Negatives" section above\nfor ideas on the cause, and how to fix it.')))),(0,r.mdx)("h3",{id:"model-explorer-approach"},"Model explorer approach"),(0,r.mdx)("p",null,"This approach uses the ",(0,r.mdx)("a",{parentName:"p",href:"/docs/pysa-explore"},"Pysa Model Explorer")," to interactively\nexplore the taint output results."),(0,r.mdx)("ol",{start:2},(0,r.mdx)("li",{parentName:"ol"},"Perform a full run using the ",(0,r.mdx)("inlineCode",{parentName:"li"},"--save-results-to")," parameters."),(0,r.mdx)("li",{parentName:"ol"},"Start the ",(0,r.mdx)("a",{parentName:"li",href:"/docs/pysa-explore"},"Pysa Model Explorer"),". For each function or method\nidentified in step 1, retrieve the fully qualified name of the callable using\n",(0,r.mdx)("inlineCode",{parentName:"li"},"callables_containing"),", then use ",(0,r.mdx)("inlineCode",{parentName:"li"},"print_model(<fully-qualified-name>)"),".",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"If the return variable should be tainted, you should see a source on the\n",(0,r.mdx)("inlineCode",{parentName:"li"},"result")," port."),(0,r.mdx)("li",{parentName:"ul"},"If an argument should be tainted, you should see a sink on a port named\n",(0,r.mdx)("inlineCode",{parentName:"li"},"formal(<argument-name>)"),"."),(0,r.mdx)("li",{parentName:"ul"},"This should allow you to figure out in which callable the taint is\nincorrectly lost (for a false negative) or where the taint is incorrectly\nkept (for a false positive)."),(0,r.mdx)("li",{parentName:"ul"},"If you still don't know what is wrong, you can try to add a\n",(0,r.mdx)("a",{parentName:"li",href:"/docs/pysa-tips#pyre_dump"},(0,r.mdx)("inlineCode",{parentName:"a"},"pyre_dump"))," call in a given callable, and run\npysa again. This will produce very verbose logs, which might be hard to\nnavigate.")))),(0,r.mdx)("h3",{id:"example-using-reveal_taint"},"Example using ",(0,r.mdx)("inlineCode",{parentName:"h3"},"reveal_taint")),(0,r.mdx)("p",null,"Pysa will not be able to detect a vulnerability in the following code:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'from django.http import HttpRequest, HttpResponse\n\nclass Runner:\n    def run(self, command: str) -> None:\n        eval(command)\n\ndef get_command(request: HttpRequest) -> str:\n    command = request.GET["command"]\n    return command\n\ndef execute_command(runner: Runner, command):\n    runner.run(command)\n\ndef start(request: HttpRequest):\n    command = get_command(request)\n    runner = Runner()\n    execute_command(runner, command)\n')),(0,r.mdx)("p",null,"Folling the above debugging steps we identify the flow of data from beginning to\nend, and add debugging statements:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'from django.http import HttpRequest, HttpResponse\n\nclass Runner:\n    def run(self, command: str) -> None:\n        reveal_type(command)\n        reveal_taint(command)\n        eval(command) # 5. User controlled data reaches the sink in here\n\ndef get_command(request: HttpRequest) -> str:\n    command = request.GET["command"] # 1. User controlled data originates here\n    reveal_type(command)\n    reveal_taint(command)\n    return command\n\ndef execute_command(runner: Runner, command):\n    reveal_type(command)\n    reveal_taint(command)\n    reveal_type(runner)\n    reveal_taint(runner)\n    runner.run(command) # 4. User controlled data is passed in here\n\ndef start(request: HttpRequest):\n    command = get_command(request) # 2. User controlled data is returned here\n    reveal_type(command)\n    reveal_taint(command)\n    runner = Runner()\n    execute_command(runner, command) # 3. User controlled data is passed in here\n')),(0,r.mdx)("p",null,"See the appendix for the full output of running ",(0,r.mdx)("inlineCode",{parentName:"p"},"pyre --noninteractive analyze")," on this example."),(0,r.mdx)("p",null,"Starting at 1), we see this in the output:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},'2020-12-28 13:02:36,486 [PID 3382063] WARNING integration_test.reveal_taint:13:4-13:16: Revealed forward taint for `command`: @integration_test.reveal_taint:11:14-11:25 -> UserControlled -> SimpleFeature: [Features.Simple.LeafName {leaf = "Obj{django.http.request.HttpRequest.GET}";\n2020-12-28 13:02:36,486 [PID 3382063] WARNING   port = None}], ComplexFeature: [], TraceLength: 0, FirstIndex: ["command"], FirstField: []\n2020-12-28 13:02:36,486 [PID 3382063] WARNING UserControlled_Payload -> SimpleFeature: [Features.Simple.LeafName {leaf = "Obj{django.http.request.HttpRequest.GET}";\n2020-12-28 13:02:36,486 [PID 3382063] WARNING   port = None}], ComplexFeature: [], TraceLength: 0, FirstIndex: ["command"], FirstField: []\n2020-12-28 13:02:36,486 [PID 3382063] WARNING\n2020-12-28 13:02:36,486 [PID 3382063] WARNING integration_test.reveal_taint:13:4-13:25: Revealed backward taint for `command`: declaration -> LocalReturn -> SimpleFeature: [], ComplexFeature: [(Features.Complex.ReturnAccessPath [])], TraceLength: 4611686018427387903, FirstIndex: [], FirstField: []\n')),(0,r.mdx)("p",null,"Removing the timestamps and other noise gives us:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},'integration_test.reveal_taint:13:4-13:16:\n  Revealed forward taint for `command`:\n    @integration_test.reveal_taint:11:14-11:25 -> UserControlled ->\n    SimpleFeature: [\n      Features.Simple.LeafName {\n        leaf = "Obj{django.http.request.HttpRequest.GET}"; port = None\n      }\n    ],\n    ComplexFeature: [],\n    TraceLength: 0,\n    FirstIndex: ["command"],\n    FirstField: []\n\n    UserControlled_Payload -> SimpleFeature: [\n      Features.Simple.LeafName {\n        leaf = "Obj{django.http.request.HttpRequest.GET}"; port = None\n      }\n    ],\n    ComplexFeature: [],\n    TraceLength: 0,\n    FirstIndex: ["command"],\n    FirstField: []\n\nintegration_test.reveal_taint:13:4-13:25:\n  Revealed backward taint for `command`:\n    declaration -> LocalReturn ->\n    SimpleFeature: [],\n    ComplexFeature: [(Features.Complex.ReturnAccessPath [])],\n    TraceLength: 4611686018427387903,\n    FirstIndex: [],\n    FirstField: []\n')),(0,r.mdx)("p",null,"For debugging false negatives, the only portion we care about is:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"  Revealed forward taint for `command`:\n    @integration_test.reveal_taint:11:14-11:25 -> UserControlled\n")),(0,r.mdx)("p",null,"This confirms that on line 11 (characters 14-25), we did indeed detect that\n",(0,r.mdx)("inlineCode",{parentName:"p"},"command")," was tainted as ",(0,r.mdx)("inlineCode",{parentName:"p"},"UserControlled"),"."),(0,r.mdx)("p",null,"Moving on to 2, the ",(0,r.mdx)("inlineCode",{parentName:"p"},"forward taint")," output again tells us that we have\n",(0,r.mdx)("inlineCode",{parentName:"p"},"UserControlled")," taint on ",(0,r.mdx)("inlineCode",{parentName:"p"},"command")," at line 26 (characters 4-16)."),(0,r.mdx)("p",null,"Starting with 4, we notice that we no longer see ",(0,r.mdx)("inlineCode",{parentName:"p"},"UserControlled")," or\n",(0,r.mdx)("inlineCode",{parentName:"p"},"RemoteCodeExecution")," in our revealed forward or backwards taint:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"2020-12-28 13:02:35,472 [PID 3382063] WARNING integration_test.reveal_taint:18:4-18:16: Revealed forward taint for `command`:\n2020-12-28 13:02:35,472 [PID 3382063] WARNING\n2020-12-28 13:02:35,472 [PID 3382063] WARNING integration_test.reveal_taint:18:4-18:25: Revealed backward taint for `command`:\n2020-12-28 13:02:35,472 [PID 3382063] WARNING\n")),(0,r.mdx)("p",null,"This has helped us narrow down the problem to the ",(0,r.mdx)("inlineCode",{parentName:"p"},"execute_command")," function. In\nthe end, the problem was that we did not have type information on ",(0,r.mdx)("inlineCode",{parentName:"p"},"runner"),", so\nPysa did not know where the definition of ",(0,r.mdx)("inlineCode",{parentName:"p"},"runner.run")," was. Without knowing\nwhere the definition was, Pysa couldn't know that ",(0,r.mdx)("inlineCode",{parentName:"p"},"run")," containted a sink and\nthus couldn't know that ",(0,r.mdx)("inlineCode",{parentName:"p"},"command")," eventually reached that sink."),(0,r.mdx)("h2",{id:"appendix"},"Appendix"),(0,r.mdx)("p",null,"Subset of the output from running ",(0,r.mdx)("inlineCode",{parentName:"p"},"pyre --noninteractive analyze")," on the\nexample:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},'2020-12-28 13:02:31,719 [PID 3382063] PERFORMANCE Overrides recorded: 2.408138s\n2020-12-28 13:02:31,719 [PID 3382063] INFO Building call graph...\n2020-12-28 13:02:34,166 [PID 3382063] PERFORMANCE Call graph built: 2.447174s\n2020-12-28 13:02:34,166 [PID 3382063] INFO Call graph edges: 100\n2020-12-28 13:02:34,166 [PID 3382063] INFO Computing overrides...\n2020-12-28 13:02:34,311 [PID 3382063] PERFORMANCE Computed overrides: 0.144886s\n2020-12-28 13:02:34,311 [PID 3382063] PERFORMANCE Pre-fixpoint computation for static analysis: 7.664068s\n2020-12-28 13:02:34,311 [PID 3382063] INFO Analysis fixpoint started for 3075 overrides 68 functions...\n2020-12-28 13:02:34,311 [PID 3382063] INFO Iteration #0. 3143 Callables [...]\n2020-12-28 13:02:35,471 [PID 3382063] WARNING integration_test.reveal_taint:6:8-6:19: Revealed type for command: str\n2020-12-28 13:02:35,471 [PID 3382063] WARNING integration_test.reveal_taint:7:8-7:20: Revealed forward taint for `command`:\n2020-12-28 13:02:35,471 [PID 3382063] WARNING\n2020-12-28 13:02:35,471 [PID 3382063] WARNING integration_test.reveal_taint:7:8-7:29: Revealed backward taint for `command`: @integration_test.reveal_taint:8:13-8:20 -> RemoteCodeExecution -> SimpleFeature: [Features.Simple.LeafName {leaf = "eval"; port = None}], ComplexFeature: [], TraceLength: 0, FirstIndex: [], FirstField: []\n2020-12-28 13:02:35,472 [PID 3382063] WARNING\n2020-12-28 13:02:35,472 [PID 3382063] WARNING integration_test.reveal_taint:17:4-17:15: Revealed type for command: typing.Any\n2020-12-28 13:02:35,472 [PID 3382063] WARNING integration_test.reveal_taint:18:4-18:16: Revealed forward taint for `command`:\n2020-12-28 13:02:35,472 [PID 3382063] WARNING\n2020-12-28 13:02:35,472 [PID 3382063] WARNING integration_test.reveal_taint:19:4-19:15: Revealed type for command: typing.Any\n2020-12-28 13:02:35,472 [PID 3382063] WARNING integration_test.reveal_taint:20:4-20:16: Revealed forward taint for `command`:\n2020-12-28 13:02:35,472 [PID 3382063] WARNING\n2020-12-28 13:02:35,472 [PID 3382063] WARNING integration_test.reveal_taint:20:4-20:25: Revealed backward taint for `command`:\n2020-12-28 13:02:35,472 [PID 3382063] WARNING\n2020-12-28 13:02:35,472 [PID 3382063] WARNING integration_test.reveal_taint:18:4-18:25: Revealed backward taint for `command`:\n2020-12-28 13:02:35,472 [PID 3382063] WARNING\n2020-12-28 13:02:35,473 [PID 3382063] WARNING integration_test.reveal_taint:12:4-12:15: Revealed type for command: str\n2020-12-28 13:02:35,473 [PID 3382063] WARNING integration_test.reveal_taint:13:4-13:16: Revealed forward taint for `command`: @integration_test.reveal_taint:11:14-11:25 -> UserControlled -> SimpleFeature: [Features.Simple.LeafName {leaf = "Obj{django.http.request.HttpRequest.GET}";\n2020-12-28 13:02:35,473 [PID 3382063] WARNING   port = None}], ComplexFeature: [], TraceLength: 0, FirstIndex: ["command"], FirstField: []\n2020-12-28 13:02:35,473 [PID 3382063] WARNING UserControlled_Payload -> SimpleFeature: [Features.Simple.LeafName {leaf = "Obj{django.http.request.HttpRequest.GET}";\n2020-12-28 13:02:35,473 [PID 3382063] WARNING   port = None}], ComplexFeature: [], TraceLength: 0, FirstIndex: ["command"], FirstField: []\n2020-12-28 13:02:35,473 [PID 3382063] WARNING\n2020-12-28 13:02:35,473 [PID 3382063] WARNING integration_test.reveal_taint:13:4-13:25: Revealed backward taint for `command`: declaration -> LocalReturn -> SimpleFeature: [], ComplexFeature: [(Features.Complex.ReturnAccessPath [])], TraceLength: 4611686018427387903, FirstIndex: [], FirstField: []\n2020-12-28 13:02:35,473 [PID 3382063] WARNING\n2020-12-28 13:02:35,480 [PID 3382063] WARNING integration_test.reveal_taint:25:4-25:15: Revealed type for command: str\n2020-12-28 13:02:35,480 [PID 3382063] WARNING integration_test.reveal_taint:26:4-26:16: Revealed forward taint for `command`: via call@integration_test.reveal_taint:24:14-24:34[integration_test.reveal_taint.get_command][{ root = LocalResult; path = [] }] -> UserControlled -> SimpleFeature: [Features.Simple.LeafName {leaf = "Obj{django.http.request.HttpRequest.GET}";\n2020-12-28 13:02:35,480 [PID 3382063] WARNING   port = None}], ComplexFeature: [], TraceLength: 1, FirstIndex: ["command"], FirstField: []\n2020-12-28 13:02:35,480 [PID 3382063] WARNING UserControlled_Payload -> SimpleFeature: [Features.Simple.LeafName {leaf = "Obj{django.http.request.HttpRequest.GET}";\n2020-12-28 13:02:35,480 [PID 3382063] WARNING   port = None}], ComplexFeature: [], TraceLength: 1, FirstIndex: ["command"], FirstField: []\n2020-12-28 13:02:35,480 [PID 3382063] WARNING\n2020-12-28 13:02:35,481 [PID 3382063] WARNING integration_test.reveal_taint:26:4-26:25: Revealed backward taint for `command`:\n2020-12-28 13:02:35,481 [PID 3382063] WARNING\n2020-12-28 13:02:35,546 [PID 3382063] PERFORMANCE Expensive callables for iteration 0:\n2020-12-28 13:02:35,577 [PID 3382063] INFO Iteration #0, 3143 callables, heap size 46105024 took 1.266790s\n2020-12-28 13:02:35,578 [PID 3382063] INFO Iteration #1. 3038 Callables [...]\n2020-12-28 13:02:36,482 [PID 3382063] WARNING integration_test.reveal_taint:6:8-6:19: Revealed type for command: str\n2020-12-28 13:02:36,482 [PID 3382063] WARNING integration_test.reveal_taint:7:8-7:20: Revealed forward taint for `command`:\n2020-12-28 13:02:36,483 [PID 3382063] WARNING\n2020-12-28 13:02:36,483 [PID 3382063] WARNING integration_test.reveal_taint:7:8-7:29: Revealed backward taint for `command`: @integration_test.reveal_taint:8:13-8:20 -> RemoteCodeExecution -> SimpleFeature: [Features.Simple.LeafName {leaf = "eval"; port = None}], ComplexFeature: [], TraceLength: 0, FirstIndex: [], FirstField: []\n2020-12-28 13:02:36,483 [PID 3382063] WARNING\n2020-12-28 13:02:36,486 [PID 3382063] WARNING integration_test.reveal_taint:12:4-12:15: Revealed type for command: str\n2020-12-28 13:02:36,486 [PID 3382063] WARNING integration_test.reveal_taint:13:4-13:16: Revealed forward taint for `command`: @integration_test.reveal_taint:11:14-11:25 -> UserControlled -> SimpleFeature: [Features.Simple.LeafName {leaf = "Obj{django.http.request.HttpRequest.GET}";\n2020-12-28 13:02:36,486 [PID 3382063] WARNING   port = None}], ComplexFeature: [], TraceLength: 0, FirstIndex: ["command"], FirstField: []\n2020-12-28 13:02:36,486 [PID 3382063] WARNING UserControlled_Payload -> SimpleFeature: [Features.Simple.LeafName {leaf = "Obj{django.http.request.HttpRequest.GET}";\n2020-12-28 13:02:36,486 [PID 3382063] WARNING   port = None}], ComplexFeature: [], TraceLength: 0, FirstIndex: ["command"], FirstField: []\n2020-12-28 13:02:36,486 [PID 3382063] WARNING\n2020-12-28 13:02:36,486 [PID 3382063] WARNING integration_test.reveal_taint:13:4-13:25: Revealed backward taint for `command`: declaration -> LocalReturn -> SimpleFeature: [], ComplexFeature: [(Features.Complex.ReturnAccessPath [])], TraceLength: 4611686018427387903, FirstIndex: [], FirstField: []\n2020-12-28 13:02:36,486 [PID 3382063] WARNING\n2020-12-28 13:02:36,486 [PID 3382063] WARNING integration_test.reveal_taint:25:4-25:15: Revealed type for command: str\n2020-12-28 13:02:36,486 [PID 3382063] WARNING integration_test.reveal_taint:26:4-26:16: Revealed forward taint for `command`: via call@integration_test.reveal_taint:24:14-24:34[integration_test.reveal_taint.get_command][{ root = LocalResult; path = [] }] -> UserControlled -> SimpleFeature: [Features.Simple.LeafName {leaf = "Obj{django.http.request.HttpRequest.GET}";\n2020-12-28 13:02:36,486 [PID 3382063] WARNING   port = None}], ComplexFeature: [], TraceLength: 1, FirstIndex: ["command"], FirstField: []\n2020-12-28 13:02:36,486 [PID 3382063] WARNING UserControlled_Payload -> SimpleFeature: [Features.Simple.LeafName {leaf = "Obj{django.http.request.HttpRequest.GET}";\n2020-12-28 13:02:36,487 [PID 3382063] WARNING   port = None}], ComplexFeature: [], TraceLength: 1, FirstIndex: ["command"], FirstField: []\n2020-12-28 13:02:36,487 [PID 3382063] WARNING\n2020-12-28 13:02:36,492 [PID 3382063] WARNING integration_test.reveal_taint:26:4-26:25: Revealed backward taint for `command`:\n2020-12-28 13:02:36,492 [PID 3382063] WARNING\n2020-12-28 13:02:36,552 [PID 3382063] PERFORMANCE Expensive callables for iteration 1:\n2020-12-28 13:02:36,585 [PID 3382063] INFO Iteration #1, 3038 callables, heap size 46521728 took 1.007461s\n2020-12-28 13:02:36,585 [PID 3382063] INFO Iteration #2. 23 Callables [...]\n2020-12-28 13:02:37,018 [PID 3382063] PERFORMANCE Expensive callables for iteration 2:\n2020-12-28 13:02:37,018 [PID 3382063] INFO Iteration #2, 23 callables, heap size 46530432 took 0.432597s\n2020-12-28 13:02:37,018 [PID 3382063] INFO Iteration #3. 2 Callables [integration_test.string_concatenation.bad_1 (fun), integration_test.string_concatenation.bad_2 (fun)]\n2020-12-28 13:02:37,130 [PID 3382063] PERFORMANCE Expensive callables for iteration 3:\n2020-12-28 13:02:37,131 [PID 3382063] INFO Iteration #3, 2 callables, heap size 46532352 took 0.113038s\n2020-12-28 13:02:37,131 [PID 3382063] INFO Iteration #4. 0 Callables []\n2020-12-28 13:02:37,131 [PID 3382063] INFO Fixpoint iterations: 4\n2020-12-28 13:02:37,348 [PID 3382063] PERFORMANCE Analysis fixpoint complete: 3.037628s\n2020-12-28 13:02:37,369 [PID 3382063] PERFORMANCE Analyze: 18.289002s\n')))}c.isMDXComponent=!0}}]);